<!DOCTYPE html>
<html lang="ko">

<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>팀 매칭 & 점수 관리</title>
    <style>
        :root {
            --bg: #0b0f14;
            --panel: #111826;
            --muted: #8aa0b8;
            --text: #e6eef8;
            --acc: #4da3ff;
            --acc2: #22c55e;
            --warn: #ef4444;
        }

        * {
            box-sizing: border-box
        }

        body {
            margin: 0;
            font-family: Inter, Pretendard, system-ui, -apple-system, Segoe UI, Roboto, "Noto Sans KR", Arial, sans-serif;
            background: linear-gradient(180deg, #09111a, #0b0f14 30%, #0f172a);
            color: var(--text)
        }

        .wrap {
            margin: 28px auto;
            padding: 20px
        }

        h1 {
            font-size: 22px;
            margin: 0 0 14px;
            letter-spacing: .2px;
            display: flex;
            gap: 10px;
            align-items: center
        }

        .bar {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
            align-items: center;
            margin-bottom: 14px
        }

        .btn {
            border: none;
            border-radius: 12px;
            padding: 10px 14px;
            font-weight: 600;
            background: #1e293b;
            color: #dbe7f8;
            cursor: pointer;
            transition: .15s
        }

        .btn:hover {
            transform: translateY(-1px);
            box-shadow: 0 6px 16px rgba(77, 163, 255, .15)
        }

        .btn.primary {
            background: var(--acc);
            color: #031427
        }

        .btn.success {
            background: var(--acc2);
            color: #06220f
        }

        .btn.warn {
            background: var(--warn)
        }

        .btn.ghost {
            background: #0b1220;
            color: #9db7d9;
            border: 1px solid #20304a
        }

        .btn.small {
            padding: 6px 10px;
            border-radius: 10px
        }

        /* ===== Layout ===== */
        .grid {
            display: grid;
            /* 왼쪽 약간 축소(1.5fr), 오른쪽 최소 폭 확대(420px) */
            grid-template-columns: minmax(0, 0.7fr) minmax(500px, 1fr);
            gap: 14px;
            min-width: 0;
        }

        @media (max-width: 980px) {
            .grid {
                grid-template-columns: 1fr;
                /* 좁은 화면에서는 한 줄 */
            }
        }

        .panel {
            min-width: 0;
            overflow-x: hidden;
        }

        .panel .hd {
            padding: 12px 14px;
            border-bottom: 1px solid #1c2b45;
            display: flex;
            align-items: center;
            justify-content: space-between
        }

        .panel .hd .title {
            font-weight: 800;
            font-size: 14px;
            letter-spacing: .6px;
            text-transform: uppercase;
            color: #a9c3e6
        }

        .panel .bd {
            padding: 14px
        }

        .muted {
            color: var(--muted)
        }

        input[type="text"],
        input[type="number"] {
            background: #0a1220;
            border: 1px solid #233656;
            color: #e6eef8;
            border-radius: 10px;
            padding: 9px 11px
        }

        input[type="file"] {
            color: #9bb3cf
        }

        .team {
            border: 1px dashed #2a4168;
            border-radius: 14px;
            padding: 12px;
            background: linear-gradient(180deg, #0c1626, #0c1422);
            min-width: 0
        }

        .team h3 {
            margin: 0 0 8px;
            font-size: 16px;
            display: flex;
            justify-content: space-between;
            align-items: center
        }

        .team ul {
            list-style: none;
            margin: 0;
            padding: 4px 0;
            display: flex;
            flex-direction: column;
            gap: 10px;
            min-height: 263px;
            overflow-y: auto;
            overflow-x: hidden;
            scrollbar-gutter: stable both-edges;
            padding-right: 6px;
        }

        /* 팀 행 */
        .teamRow {
            display: grid;
            grid-template-columns: minmax(12ch, 1fr) 80px 70px minmax(60px, max-content);
            gap: 8px;
            padding: 10px 14px;
            background: #0e1a2a;
            border: 1px solid #1f2e47;
            border-radius: 12px;
            align-items: center;
        }

        .teamRow:hover {
            transform: translateY(-1px);
            box-shadow: 0 8px 18px rgba(0, 0, 0, .25);
            transition: .15s;
        }

        .teamRow .cell-name {
            display: -webkit-box;
            -webkit-line-clamp: 2;
            -webkit-box-orient: vertical;
            overflow: hidden;
            white-space: normal;
            text-overflow: unset;
            line-height: 1.3;
            text-align:center;
        }

        .teamRow .cell-line {
            text-align: center;
            opacity: .9
        }

        .teamRow .cell-wr {
            text-align: center
        }

        .teamRow .cell-score {
            text-align: right;
            justify-self: end;
            white-space: nowrap;
            min-width: 60px;
        }

        .tabnum {
            font-variant-numeric: tabular-nums;
            font-feature-settings: "tnum" 1
        }

        .avg {
            font-weight: 800
        }

        .avg .good {
            color: var(--acc2)
        }

        .avg .bad {
            color: #f59e0b
        }

        .winbar {
            display: flex;
            gap: 8px;
            flex-wrap: wrap;
            align-items: center;
            min-width: 0
        }

        .winbar label {
            align-items: center;
            gap: 6px;
        }

        .winbar label input {
            width: 80px;
            max-width: 80px
        }

        .winbar label select {
            max-width: 180px
        }

        .winbar .btn.success {
            min-width: 108px;
            white-space: nowrap;
            flex: 0 0 auto
        }

        .winbar .btn.ghost {
            white-space: nowrap
        }

        .teamControls {
            display: flex;
            gap: 8px;
            align-items: center;
            margin: 8px 0 12px
        }

        /* ===== Roster ===== */
        .rosterTable {
            border: 1px solid #1c2b45;
            border-radius: 12px;
            overflow: hidden;
            margin-bottom: 10px
        }

        .rhead,
        .rbody {
            width: 100%;
            table-layout: fixed;
            border-collapse: separate;
            border-spacing: 0 8px
        }

        .rhead thead th {
            font-size: 12px;
            color: #8fb1d6;
            font-weight: 700;
            text-align: center;
            padding: 8px;
            background: #0c1422
        }

        .rscroll {
            max-height: 440px;
            overflow-y: auto;
            overflow-x: hidden;
            background: transparent;
            padding: 6px
        }

        .rbody tbody tr {
            background: linear-gradient(180deg, #0b1422, #0a111c);
            border: 1px solid #1c2b45
        }

        .rbody tbody tr td {
            padding: 10px 8px;
            text-align: center
        }

        .rbody tbody tr td:first-child {
            border-top-left-radius: 12px;
            border-bottom-left-radius: 12px
        }

        .rbody tbody tr td:last-child {
            border-top-right-radius: 12px;
            border-bottom-right-radius: 12px
        }

        /* 이름은 테이블 안에서만 한 줄 처리 */
        .rbody .cell-name,
        .rhead th:nth-child(2) {
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
            min-width: 12ch;
            text-align: center
        }

        .cell-line {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 6px
        }

        .line-select {
            width: 54px;
            height: 30px;
            background: #0a1220;
            border: 1px solid #233656;
            color: #e6eef8;
            border-radius: 8px;
            appearance: none;
            text-align: center
        }

        /* 폼 전용 더 작은 셀렉트 */
        #linePrimaryInput,
        #lineSecondaryInput {
            width: 46px;
            height: 28px;
            font-size: 12px
        }

        .line-slash {
            opacity: .6
        }

        .rscroll input.cell-score,
        .rscroll input.cell-games {
            width: 100% !important;
            max-width: 100%;
            box-sizing: border-box
        }

        .wl-badge,
        .wr-badge {
            font-size: 11px;
            opacity: .85
        }

        .wr-good {
            color: var(--acc2)
        }

        .wr-bad {
            color: var(--warn)
        }

        select {
            max-width: 180px !important;
            background: #0a1220;
            border: 1px solid #233656;
            color: #e6eef8;
            border-radius: 10px;
            height: 34px;
            padding: 0 10px;
            appearance: none;
        }

        /* 인원 관리 상단 바를 그리드로 정리 */
        .listbar.manage {
            display: grid;
            grid-template-columns: minmax(180px, 1fr) 120px repeat(2, auto) auto auto;
            gap: 8px 12px;
            align-items: center;
        }

        @media (max-width: 1100px) {
            .listbar.manage {
                grid-template-columns: minmax(160px, 1fr) 110px auto auto;
            }
        }

        /* 점수 인풋 살짝 컴팩트 */
        .listbar.manage #scoreInput {
            width: 110px !important;
        }

        /* 주/부 라인 선택 작은 스타일 유지 */
        #linePrimaryInput,
        #lineSecondaryInput {
            width: 46px;
            height: 28px;
            font-size: 12px;
        }

        /* 오른쪽 '목록 정렬' 레이블이 항상 우측에 붙도록 */
        .listbar.manage label[for="rosterSort"],
        .listbar.manage select#rosterSort {
            justify-self: end;
        }
    </style>
</head>

<body>
    <div class="wrap">
        <h1>팀 매칭 & 점수 관리</h1>
        <div class="grid">
            <!-- Left: Teams -->
            <div class="panel">
                <div class="hd">
                    <div class="title">Teams</div>
                </div>
                <div class="bd">
                    <div class="teamControls">
                        <label class="muted">팀 섞기 기준
                            <select id="balanceMode">
                                <option value="ignore_line">라인무시</option>
                                <option value="prefer_line" selected>라인우선</option>
                                <option value="prefer_mmr">MMR우선</option>
                            </select>
                        </label>
                        <label class="muted">팀 정렬
                            <select id="teamSort">
                                <option value="name" selected>이름 ▲</option>
                                <option value="line">주/부라인</option>
                                <option value="wr">승률 ▲</option>
                                <option value="score">점수 ▲</option>
                            </select>
                        </label>
                    </div>

                    <div class="teams">
                        <div class="team" id="team1Box">
                            <h3>1팀 <span class="avg" id="avg1">평균 0</span></h3>
                            <ul id="team1"></ul>
                        </div>
                        <div class="team" id="team2Box">
                            <h3>2팀 <span class="avg" id="avg2">평균 0</span></h3>
                            <ul id="team2"></ul>
                        </div>
                    </div>

                    <div class="winbar" style="margin-top:10px">

                        <div style="width: 100%;">
                            <label class="muted">점수 방식
                                <select id="scoringMode">
                                    <option value="elo">Elo 레이팅</option>
                                    <option value="fixed">고정 가산/감산</option>
                                </select>
                            </label>
                            <button class="btn success" id="btnWin1" title="1팀 승">1팀 승리</button>
                            <button class="btn success" id="btnWin2" title="2팀 승">2팀 승리</button>
                        </div>

                        <label class="muted">Elo K <input id="eloK" type="number" value="60" /></label>
                        <label class="muted">승리 보상 <input id="winBonusInput" type="number" value="30" /></label>
                        <div style="margin-left:auto;">
                            <button class="btn primary" id="btnRemakeTeams">현재 멤버로 팀 다시 짜기</button>
                            <button class="btn ghost" id="btnClearTeams">팀 비우기</button>
                        </div>

                    </div>

                    <div class="muted">배치: 각 플레이어의 <b>현재 판수가 ≤ 10</b>이면 점수 변화가 <b>2배</b>로 적용됩니다.</div>
                    <div class="muted">고정감산을 선택할 경우 승리 보상만큼의 점수가 가산/감산 됩니다.</div>
                    <div class="muted">멤버를 인원관리에 드래그 드롭하여 제외할 수 있습니다.</div>
                    <div class="muted">
                        티어 예시 (400점 단위):<br>
                        Iron: 0–399<br>
                        Bronze: 400–799<br> 
                        Silver: 800–1199<br> 
                        Gold: 1200–1599<br>
                        Platinum: 1600–1999<br> 
                        Emerald: 2000–2399<br> 
                        Diamond: 2400–2799<br>
                        Master: 2800–3199<br> 
                        Grandmaster: 3200–3599<br> 
                        Challenger: 3600+
                    </div>
                </div>
            </div>

            <!-- Right: Roster + IO -->
            <div class="panel">
                <div class="hd">
                    <div class="title">인원 관리</div>
                </div>
                <div class="bd">
                    <div class="listbar manage" style="gap:10px;align-items:center;flex-wrap:wrap;">
                        <input class="grow" id="nameInput" type="text" placeholder="이름 (최대 10자)" />
                        <input style="width:120px" id="scoreInput" type="number" placeholder="초기 점수" value="1000" />
                        <label class="muted">주라인
                            <select id="linePrimaryInput" class="line-select">
                                <option value="A" selected>A</option>
                                <option value="T">T</option>
                                <option value="J">J</option>
                                <option value="M">M</option>
                                <option value="B">B</option>
                                <option value="S">S</option>
                            </select>
                        </label>
                        <label class="muted">부라인
                            <select id="lineSecondaryInput" class="line-select">
                                <option value="A" selected>A</option>
                                <option value="T">T</option>
                                <option value="J">J</option>
                                <option value="M">M</option>
                                <option value="B">B</option>
                                <option value="S">S</option>
                            </select>
                        </label>
                        <button class="btn" id="btnAdd">인원추가</button>

                        <label class="muted" style="margin-left:auto">
                            <select id="rosterSort">
                                <option value="name" selected>이름 ▲</option>
                                <option value="wr">승률 ▼</option>
                                <option value="score">점수 ▼</option>
                            </select>
                        </label>
                    </div>

                    <div class="rosterTable">
                        <table class="rhead" style="padding-left : 10px; padding-right:8px;">
                            <colgroup>
                                <col style="width:44px" />
                                <col style="width:140px" />
                                <col style="width:110px" />
                                <col style="width:80px" />
                                <col style="width:80px" />
                                <col style="width:90px" />
                                <col style="width:50px" />
                            </colgroup>
                            <thead>
                                <tr>
                                    <th><input type="checkbox" id="checkAll"></th>
                                    <th>이름</th>
                                    <th>라인<br><span class="muted" style="font-weight:400;">주/부</span></th>
                                    <th>점수</th>
                                    <th>판수</th>
                                    <th>승/패</th>
                                    <th>승률</th>
                                </tr>
                            </thead>
                        </table>
                        <div class="rscroll">
                            <table class="rbody">
                                <colgroup>
                                    <col style="width:44px" />
                                    <col style="width:140px" />
                                    <col style="width:110px" />
                                    <col style="width:80px" />
                                    <col style="width:80px" />
                                    <col style="width:90px" />
                                    <col style="width:50px" />
                                </colgroup>
                                <tbody id="rosterBody"></tbody>
                            </table>
                        </div>
                    </div>
                    <div class="bar">
                        <button class="btn primary" id="btnMakeTeams">팀 짜기 (선택 인원 짝수)</button>
                        <button class="btn ghost" id="btnToTeam1">선택 → 1팀</button>
                        <button class="btn ghost" id="btnToTeam2">선택 → 2팀</button>
                        <button class="btn ghost" id="btnRemoveFromTeams">선택한 인원을 팀에서 제거</button>
                    </div>
                    <div class="listbar">
                        <button class="btn warn" id="btnDelete">인원 삭제(선택)</button>
                        <button class="btn" id="btnSave">텍스트로 저장</button>
                    </div>
                    <div class="listbar">
                        <input id="fileInput" type="file" accept=".txt,.json" />
                        <button class="btn" id="btnLoad">불러오기</button>
                        <span class="muted">현재 멤버 목록을 저장하여 불러올 수 있습니다.</span>
                    </div>

                </div>
            </div>
        </div>
    </div>

    <script>
        // ===== 상태키 =====
        const STORAGE_KEY = 'team_roster_v1', WIN_BONUS_KEY = 'win_bonus_v1', MODE_KEY = 'scoring_mode_v1', ELO_K_KEY = 'elo_k_v1';

        let roster = [];                 // {id,name,score,games,wins,losses,mainLine,subLine}
        let currentTeams = { team1: [], team2: [] }; // ids

        // ===== 유틸 =====
        const uid = () => Math.random().toString(36).slice(2, 10);
        const clamp = (n, min, max) => Math.max(min, Math.min(max, n));
        const avg = arr => arr.length ? (arr.reduce((a, b) => a + b, 0) / arr.length) : 0;
        const isPlacement = g => (Number(g) || 0) <= 10;
        const winRate = p => { const w = Number(p.wins) || 0, l = Number(p.losses) || 0, t = w + l; return t ? Math.round((w / t) * 100) : 0 };
        const wrClass = rate => rate >= 53 ? 'wr-good' : (rate <= 47 ? 'wr-bad' : '');
        const LINES = ['T', 'J', 'M', 'B', 'S', 'A'];
        const LINE_TITLE = { T: 'Top', J: 'Jungle', M: 'Mid', B: 'Bottom', S: 'Supporter', A: 'All' };
        const normLine = v => {
            v = String(v || 'A').toUpperCase();
            return LINES.includes(v) ? v : 'A';
        };
        const linePair = p => `${normLine(p.mainLine)}/${normLine(p.subLine)}`;
        const escapeHtml = (s = '') => s.replace(/[&<>"']/g, ch => ({ "&": "&amp;", "<": "&lt;", ">": "&gt;", "\"": "&quot;", "'": "&#039;" }[ch]));

        function saveLocal() { localStorage.setItem(STORAGE_KEY, JSON.stringify(roster)); }
        function loadLocal() {
            try {
                const raw = localStorage.getItem(STORAGE_KEY);
                if (raw) {
                    const data = JSON.parse(raw);
                    if (Array.isArray(data)) {
                        roster = data.filter(x => x && x.name).map(x => ({
                            id: x.id || uid(),
                            name: String(x.name || '').trim(),
                            score: Number(x.score) || 0,
                            games: Math.max(0, Math.floor(Number(x.games) || 0)),
                            wins: Math.max(0, Math.floor(Number(x.wins) || 0)),
                            losses: Math.max(0, Math.floor(Number(x.losses) || 0)),
                            mainLine: normLine(x.mainLine),
                            subLine: normLine(x.subLine),
                        }));
                    }
                }
            } catch (e) { console.warn(e); }
        }

        // ===== DOM =====
        const rosterBody = document.getElementById('rosterBody');
        const checkAll = document.getElementById('checkAll');
        const nameInput = document.getElementById('nameInput');
        const scoreInput = document.getElementById('scoreInput');
        const winBonusInput = document.getElementById('winBonusInput');
        const scoringModeSel = document.getElementById('scoringMode');
        const eloKInput = document.getElementById('eloK');
        const fileInput = document.getElementById('fileInput');
        const team1UL = document.getElementById('team1');
        const team2UL = document.getElementById('team2');
        const team1Box = document.getElementById('team1Box');
        const team2Box = document.getElementById('team2Box');
        const linePrimaryInput = document.getElementById('linePrimaryInput');
        const lineSecondaryInput = document.getElementById('lineSecondaryInput');
        const balanceModeSel = document.getElementById('balanceMode');
        const teamSortSel = document.getElementById('teamSort');
        const rosterSortSel = document.getElementById('rosterSort');

        const lineOptionsHTML = (sel) => ['T', 'J', 'M', 'B', 'S', 'A'].map(k => `<option value="${k}" ${sel === k ? 'selected' : ''} title="${LINE_TITLE[k]}">${k}</option>`).join('');

        // ===== 역할 배정(라인우선용) : 주 → 부 → A로 채우기 =====
        function assignRoles(team) {
            // team: [{id, mainLine, subLine, ...}]
            const roles = ['T', 'J', 'M', 'B', 'S'];
            const used = new Set();
            const assignment = {}; // role -> playerId
            let primaryAssigned = 0;

            // 1) 주라인으로 먼저 채우기
            for (const r of roles) {
                const idx = team.findIndex(p => !used.has(p.id) && normLine(p.mainLine) === r);
                if (idx >= 0) { const p = team[idx]; used.add(p.id); assignment[r] = p.id; primaryAssigned++; }
            }
            // 2) 부라인으로 채우기
            for (const r of roles) {
                if (assignment[r]) continue;
                const idx = team.findIndex(p => !used.has(p.id) && normLine(p.subLine) === r);
                if (idx >= 0) { const p = team[idx]; used.add(p.id); assignment[r] = p.id; }
            }
            // 3) A(아무거나)로 채우기
            for (const r of roles) {
                if (assignment[r]) continue;
                const idx = team.findIndex(p => !used.has(p.id) && (normLine(p.mainLine) === 'A' || normLine(p.subLine) === 'A'));
                if (idx >= 0) { const p = team[idx]; used.add(p.id); assignment[r] = p.id; }
            }

            const coveredRoles = Object.keys(assignment).length; // 0~5
            return { coveredRoles, primaryAssigned, assignment };
        }

        function evaluateSplit(t1, t2) {
            const sum = team => team.reduce((a, b) => a + (b.score || 0), 0);
            const diff = Math.abs(sum(t1) - sum(t2));
            // 라인 커버리지 + 주라인 반영
            const a1 = assignRoles(t1), a2 = assignRoles(t2);
            const coveredTotal = (a1.coveredRoles || 0) + (a2.coveredRoles || 0);        // 최대 10
            const primaryTotal = (a1.primaryAssigned || 0) + (a2.primaryAssigned || 0);  // 최대 10
            return { diff, coveredTotal, primaryTotal };
        }

        // ===== 팀 자동 빌드 =====
        function buildBalancedTeams(players, mode = 'prefer_line') {
            const n = players.length, half = n / 2;
            const attempts = Math.min(12000, 800 * n);
            const idx = [...Array(n).keys()];

            const better = (a, b) => {
                if (mode === 'ignore_line') {
                    if (a.diff !== b.diff) return a.diff < b.diff;
                    if (a.coveredTotal !== b.coveredTotal) return a.coveredTotal > b.coveredTotal;
                    return a.primaryTotal > b.primaryTotal;
                } else if (mode === 'prefer_mmr') {
                    if (a.diff !== b.diff) return a.diff < b.diff;
                    if (a.coveredTotal !== b.coveredTotal) return a.coveredTotal > b.coveredTotal;
                    return a.primaryTotal > b.primaryTotal;
                } else { // prefer_line
                    if (a.coveredTotal !== b.coveredTotal) return a.coveredTotal > b.coveredTotal;   // 5개 라인 다 채우는 팀 우선
                    if (a.primaryTotal !== b.primaryTotal) return a.primaryTotal > b.primaryTotal;   // 가능한 많은 주라인 배정
                    return a.diff < b.diff;                                                       // 마지막으로 MMR 균형
                }
            };

            let best = null, bestPick = null;
            for (let i = 0; i < attempts; i++) {
                shuffle(idx);
                const t1Idx = idx.slice(0, half), t2Idx = idx.slice(half, n);
                const t1 = t1Idx.map(i => players[i]), t2 = t2Idx.map(i => players[i]);
                const score = evaluateSplit(t1, t2);
                if (!best || better(score, best)) {
                    best = score; bestPick = { team1: t1.map(p => p.id), team2: t2.map(p => p.id) };
                    // 라인우선일 때 "양쪽 모두 5개 라인 커버 + 주라인 최대 + MMR 거의 동일"이면 조기 종료
                    if (mode === 'prefer_line' && best.coveredTotal === 10 && best.primaryTotal >= 8 && best.diff <= 1) break;
                    if (mode !== 'prefer_line' && best.diff === 0) break;
                }
            }
            return bestPick || { team1: players.slice(0, half).map(p => p.id), team2: players.slice(half).map(p => p.id) };
        }
        function shuffle(a) { for (let i = a.length - 1; i > 0; i--) { const j = (Math.random() * (i + 1)) | 0;[a[i], a[j]] = [a[j], a[i]]; } }

        // ===== 로스터 렌더(정렬 지원) =====
        function renderRoster() {
            const key = (rosterSortSel && rosterSortSel.value) || 'name';
            const list = roster.slice();
            list.sort((a, b) => {
                if (key === 'name') return a.name.localeCompare(b.name, 'ko');
                if (key === 'wr') return (winRate(b) - winRate(a)) || a.name.localeCompare(b.name, 'ko');
                if (key === 'score') return (b.score - a.score) || a.name.localeCompare(b.name, 'ko');
                return 0;
            });

            rosterBody.innerHTML = '';
            list.forEach(p => {
                const tr = document.createElement('tr');
                tr.setAttribute('draggable', 'true'); tr.dataset.id = p.id;
                const rate = winRate(p);
                const p1 = normLine(p.mainLine || 'A');
                const p2 = normLine(p.subLine || 'A');
                tr.innerHTML = `
                    <td><input type="checkbox" data-id="${p.id}" class="rowcheck"></td>
                    <td class="cell-name" data-id="${p.id}" title="더블클릭으로 이름 수정">${escapeHtml(p.name)}</td>
                    <td class="cell-line">
                        <select class="line-select cell-line1" data-id="${p.id}" title="주 라인">${lineOptionsHTML(p1)}</select>
                        <span class="line-slash">/</span>
                        <select class="line-select cell-line2" data-id="${p.id}" title="부 라인">${lineOptionsHTML(p2)}</select>
                    </td>
                    <td class="tabnum"><input data-id="${p.id}" class="cell-score" type="number" value="${p.score}" /></td>
                    <td class="tabnum"><input data-id="${p.id}" class="cell-games" type="number" min="0" value="${Number(p.games) || 0}" /></td>
                    <td class="tabnum"><span class="wl-badge" data-id="${p.id}">${Number(p.wins) || 0}/${Number(p.losses) || 0}</span></td>
                    <td class="tabnum"><span class="wr-badge ${wrClass(rate)}" data-id="${p.id}">${rate}%</span></td>
                `;
                rosterBody.appendChild(tr);
            });
        }

        // 값 변경 핸들링
        rosterBody.addEventListener('change', e => {
            const t = e.target;
            if (t.classList.contains('cell-line1') || t.classList.contains('cell-line2')) {
                const id = t.dataset.id; const p = roster.find(x => x.id === id); if (!p) return;
                if (t.classList.contains('cell-line1')) p.mainLine = normLine(t.value);
                if (t.classList.contains('cell-line2')) p.subLine = normLine(t.value);
                saveLocal(); return;
            }
            if (t.classList.contains('cell-score') || t.classList.contains('cell-games')) {
                const id = t.dataset.id; const p = roster.find(x => x.id === id); if (!p) return;
                if (t.classList.contains('cell-score')) { const v = Number(t.value || 0); p.score = isFinite(v) ? v : p.score; }
                else { const g = Math.max(0, Math.floor(Number(t.value || 0))); p.games = g; }
                saveLocal(); renderTeams();
            }
        });

        // 드래그 시작
        rosterBody.addEventListener('dragstart', e => {
            const row = e.target.closest('tr'); if (!row || !row.dataset.id) return;
            e.dataTransfer.setData('text/plain', row.dataset.id);
            e.dataTransfer.effectAllowed = 'move';
        });

        rosterBody.addEventListener('dblclick', e => {
            const wl = e.target.closest('.wl-badge');
            if (wl) {
                const id = wl.dataset.id;
                const p = roster.find(x => x.id === id);
                if (!p) return;
                if (confirm(`"${p.name}"의 승패를 초기화하시겠습니까?`)) {
                    p.wins = 0;
                    p.losses = 0;
                    saveLocal();
                    renderRoster();
                    renderTeams();
                }
            }
        });

        // ===== 팀 렌더 (정렬 포함) =====
        function renderTeams() {
            const t1 = currentTeams.team1.map(id => roster.find(p => p.id === id)).filter(Boolean);
            const t2 = currentTeams.team2.map(id => roster.find(p => p.id === id)).filter(Boolean);

            const a1 = avg(t1.map(p => p.score)), a2 = avg(t2.map(p => p.score));
            document.getElementById('avg1').innerHTML = `평균 <span class="${a1 >= a2 ? 'good' : 'bad'}">${a1.toFixed(1)}</span>`;
            document.getElementById('avg2').innerHTML = `평균 <span class="${a2 >= a1 ? 'good' : 'bad'}">${a2.toFixed(1)}</span>`;

            // 팀 정렬
            const sortKey = (teamSortSel && teamSortSel.value) || 'name';
            const cmp = (a, b) => {
                if (sortKey === 'name') return a.name.localeCompare(b.name, 'ko');
                if (sortKey === 'line') return linePair(a).localeCompare(linePair(b));
                if (sortKey === 'wr') return (winRate(b) - winRate(a)) || a.name.localeCompare(b.name, 'ko');
                if (sortKey === 'score') return (b.score - a.score) || a.name.localeCompare(b.name, 'ko');
                return 0;
            };
            t1.sort(cmp); t2.sort(cmp);

            team1UL.innerHTML = ''; team2UL.innerHTML = '';
            const makeRow = p => {
                const wr = winRate(p);
                const row = document.createElement('li');
                row.className = 'teamRow'; row.setAttribute('draggable', 'true'); row.dataset.id = p.id;
                row.innerHTML = `
                    <span class="cell-name" title="${escapeHtml(p.name)}">${escapeHtml(p.name)}</span>
                    <span class="cell-line tabnum" title="${LINE_TITLE[normLine(p.mainLine)]}/${LINE_TITLE[normLine(p.subLine)]}">${linePair(p)}</span>
                    <span class="cell-wr tabnum ${wrClass(wr)}">${wr}%</span>
                    <span class="cell-score tabnum">${p.score}</span>
                `;
                row.addEventListener('dragstart', e => {
                    e.dataTransfer.setData('text/plain', p.id);
                    e.dataTransfer.effectAllowed = 'move';
                });
                return row;
            };
            t1.forEach(p => team1UL.appendChild(makeRow(p)));
            t2.forEach(p => team2UL.appendChild(makeRow(p)));
        }

        // 드롭 타겟
        function bindDropTarget(ulEl, boxEl, teamNo) {
            const onDragOver = e => { e.preventDefault(); e.dataTransfer.dropEffect = 'move'; };
            const onDragEnter = () => boxEl.classList.add('drop-target');
            const onDragLeave = e => { if (!boxEl.contains(e.relatedTarget)) boxEl.classList.remove('drop-target'); };
            const onDrop = e => {
                e.preventDefault(); boxEl.classList.remove('drop-target');
                const id = e.dataTransfer.getData('text/plain'); if (!id) return; addIdToTeam(teamNo, id);
            };
            ulEl.addEventListener('dragover', onDragOver);
            ulEl.addEventListener('dragenter', onDragEnter);
            ulEl.addEventListener('dragleave', onDragLeave);
            ulEl.addEventListener('drop', onDrop);
            boxEl.addEventListener('dragover', onDragOver);
            boxEl.addEventListener('dragenter', onDragEnter);
            boxEl.addEventListener('dragleave', onDragLeave);
            boxEl.addEventListener('drop', onDrop);
        }
        bindDropTarget(team1UL, team1Box, 1);
        bindDropTarget(team2UL, team2Box, 2);

        // 인원 관리 테이블(로스터) 드롭 타겟으로 지정
        rosterBody.addEventListener('dragover', e => {
            e.preventDefault();
            rosterBody.classList.add('drop-target'); // 강조 효과 줄 수도 있음
        });
        rosterBody.addEventListener('dragleave', e => {
            if (!rosterBody.contains(e.relatedTarget)) {
                rosterBody.classList.remove('drop-target');
            }
        });
        rosterBody.addEventListener('drop', e => {
            e.preventDefault();
            rosterBody.classList.remove('drop-target');
            const id = e.dataTransfer.getData('text/plain');
            if (!id) return;
            // 팀1/팀2에서 해당 멤버 제거
            currentTeams.team1 = currentTeams.team1.filter(x => x !== id);
            currentTeams.team2 = currentTeams.team2.filter(x => x !== id);
            renderTeams();
        });

        function addIdToTeam(teamNo, id) {
            if (!id) return;
            const other = teamNo === 1 ? currentTeams.team2 : currentTeams.team1;
            const target = teamNo === 1 ? currentTeams.team1 : currentTeams.team2;
            const otherSet = new Set(other), targetSet = new Set(target);
            if (otherSet.has(id)) otherSet.delete(id);
            targetSet.add(id);
            if (teamNo === 1) { currentTeams.team2 = [...otherSet]; currentTeams.team1 = [...targetSet]; }
            else { currentTeams.team1 = [...otherSet]; currentTeams.team2 = [...targetSet]; }
            renderTeams();
        }

        // ===== 인원 추가/삭제 =====
        document.getElementById('btnAdd').addEventListener('click', () => {
            let name = (nameInput.value || '').trim();
            const score = Number(scoreInput.value || 0);
            const pLine = normLine(linePrimaryInput?.value || 'A');
            const sLine = normLine(lineSecondaryInput?.value || 'A');
            if (!name) { alert('이름을 입력하세요.'); nameInput.focus(); return; }
            if (name.length > 10) { alert('이름은 최대 10자까지만 가능합니다. 초과분은 잘립니다.'); name = name.slice(0, 10); }
            roster.push({ id: uid(), name, score: isFinite(score) ? score : 0, games: 0, wins: 0, losses: 0, mainLine: pLine, subLine: sLine });
            saveLocal(); renderRoster(); renderTeams();
            nameInput.value = ''; scoreInput.value = '1000'; if (linePrimaryInput) linePrimaryInput.value = 'A'; if (lineSecondaryInput) lineSecondaryInput.value = 'A'; nameInput.focus();
        });

        document.getElementById('btnDelete').addEventListener('click', () => {
            const checks = [...document.querySelectorAll('.rowcheck:checked')];
            if (!checks.length) { alert('삭제할 인원을 선택하세요.'); return; }
            const selected = checks.map(c => roster.find(p => p.id === c.dataset.id)).filter(Boolean);
            const msg = selected.length === 1 ? `정말로 "${selected[0].name}" 멤버를 삭제하시겠습니까?`
                : `정말로 다음 ${selected.length}명을 삭제하시겠습니까?\n` + selected.map(p => p.name).join(', ');
            if (!confirm(msg)) return;
            const ids = new Set(selected.map(p => p.id));
            roster = roster.filter(p => !ids.has(p.id));
            currentTeams.team1 = currentTeams.team1.filter(id => !ids.has(id));
            currentTeams.team2 = currentTeams.team2.filter(id => !ids.has(id));
            saveLocal(); renderRoster(); renderTeams();
        });

        // 이름 더블클릭
        rosterBody.addEventListener('dblclick', e => {
            const td = e.target.closest('.cell-name'); if (!td) return;
            const id = td.dataset.id; const p = roster.find(x => x.id === id); if (!p) return;
            let newName = prompt('이름 수정 (최대 10자)', p.name);
            if (newName != null) {
                newName = newName.trim().slice(0, 10);
                if (!newName) { alert('이름이 비었습니다.'); return; }
                p.name = newName; saveLocal(); renderRoster(); renderTeams();
            }
        });

        // 전체선택
        checkAll.addEventListener('change', () => { document.querySelectorAll('.rowcheck').forEach(cb => cb.checked = checkAll.checked); });

        // 파일 저장/불러오기
        document.getElementById('btnSave').addEventListener('click', () => {
            const blob = new Blob([JSON.stringify(roster, null, 2)], { type: 'application/json' });
            const url = URL.createObjectURL(blob); const a = document.createElement('a');
            const now = new Date(), pad = n => String(n).padStart(2, '0');
            const filename = `member_${now.getFullYear()}${pad(now.getMonth() + 1)}${pad(now.getDate())}${pad(now.getHours())}${pad(now.getMinutes())}${pad(now.getSeconds())}.txt`;
            a.href = url; a.download = filename; a.click(); URL.revokeObjectURL(url);
        });

        document.getElementById('btnLoad').addEventListener('click', () => {
            const f = fileInput.files && fileInput.files[0];
            if (!f) { alert('불러올 파일을 선택하세요.'); fileInput.click(); return; }
            const reader = new FileReader();
            reader.onload = () => {
                try {
                    const text = String(reader.result || ''); let data;
                    if (text.trim().startsWith('[') || text.trim().startsWith('{')) data = JSON.parse(text);
                    else {
                        data = text.split(/\r?\n/).map(line => {
                            if (!line.trim()) return null;
                            const parts = line.split(',').map(s => s.trim());
                            const name = parts[0]; if (!name) return null;
                            return {
                                name, score: Number(parts[1]) || 0,
                                games: parts[2] != null ? Math.max(0, Math.floor(Number(parts[2]) || 0)) : 0,
                                wins: parts[3] != null ? Math.max(0, Math.floor(Number(parts[3]) || 0)) : 0,
                                losses: parts[4] != null ? Math.max(0, Math.floor(Number(parts[4]) || 0)) : 0,
                                mainLine: normLine(parts[5] || 'A'), subLine: normLine(parts[6] || 'A'),
                            };
                        }).filter(Boolean);
                    }
                    if (!Array.isArray(data)) data = [data];
                    roster = data.map(it => ({
                        id: uid(), name: String(it.name || '').slice(0, 10),
                        score: Number(it.score) || 0, games: Math.max(0, Math.floor(Number(it.games) || 0)),
                        wins: Math.max(0, Math.floor(Number(it.wins) || 0)), losses: Math.max(0, Math.floor(Number(it.losses) || 0)),
                        mainLine: normLine(it.mainLine), subLine: normLine(it.subLine),
                    })).filter(x => x.name);
                    const validIds = new Set(roster.map(p => p.id));
                    currentTeams.team1 = currentTeams.team1.filter(id => validIds.has(id));
                    currentTeams.team2 = currentTeams.team2.filter(id => validIds.has(id));
                    saveLocal(); renderRoster(); renderTeams();
                } catch (err) { console.error(err); alert('불러오기 실패: 파일 형식을 확인하세요.'); }
            };
            reader.readAsText(f, 'utf-8');
        });

        // 팀 빌드/리메이크/정렬 변경 트리거
        document.getElementById('btnMakeTeams').addEventListener('click', () => {
            const selected = [...document.querySelectorAll('.rowcheck:checked')].map(cb => cb.dataset.id);
            if (selected.length < 2 || selected.length % 2 !== 0) { alert('짝수 인원을 선택하세요. (현재 ' + selected.length + '명)'); return; }
            const players = selected.map(id => roster.find(p => p.id === id)).filter(Boolean);
            const mode = (balanceModeSel && balanceModeSel.value) || 'prefer_line';
            currentTeams = buildBalancedTeams(players, mode); renderTeams();
        });
        document.getElementById('btnRemakeTeams').addEventListener('click', () => {
            const ids1 = currentTeams.team1 || [], ids2 = currentTeams.team2 || [];
            const all = [...ids1, ...ids2];
            if (all.length < 2 || all.length % 2 !== 0) { alert('먼저 짝수 인원으로 팀을 만들어주세요. (현재 ' + all.length + '명)'); return; }
            const players = all.map(id => roster.find(p => p.id === id)).filter(Boolean);
            if (players.length !== all.length) { alert('일부 멤버가 목록에서 사라졌습니다. 다시 선택해서 팀을 만들어주세요.'); return; }
            const mode = (balanceModeSel && balanceModeSel.value) || 'prefer_line';
            currentTeams = buildBalancedTeams(players, mode); renderTeams();
        });
        teamSortSel.addEventListener('change', renderTeams);
        rosterSortSel.addEventListener('change', renderRoster);

        document.getElementById('btnClearTeams').addEventListener('click', () => {
            currentTeams = { team1: [], team2: [] }; renderTeams();
            document.getElementById('avg1').textContent = '평균 0';
            document.getElementById('avg2').textContent = '평균 0';
        });

        // 선택 이동/제거
        document.getElementById('btnToTeam1').addEventListener('click', () => addSelectedToTeam(1));
        document.getElementById('btnToTeam2').addEventListener('click', () => addSelectedToTeam(2));
        document.getElementById('btnRemoveFromTeams').addEventListener('click', removeSelectedFromTeams);
        function addSelectedToTeam(teamNo) {
            const checks = [...document.querySelectorAll('.rowcheck:checked')];
            if (!checks.length) { alert('팀에 넣을 인원을 체크하세요.'); return; }
            const ids = checks.map(c => c.dataset.id); ids.forEach(id => addIdToTeam(teamNo, id));
        }
        function removeSelectedFromTeams() {
            const checks = [...document.querySelectorAll('.rowcheck:checked')];
            if (!checks.length) { alert('팀에서 제거할 인원을 체크하세요.'); return; }
            const ids = new Set(checks.map(c => c.dataset.id));
            currentTeams.team1 = currentTeams.team1.filter(id => !ids.has(id));
            currentTeams.team2 = currentTeams.team2.filter(id => !ids.has(id));
            renderTeams();
        }

        // 승패 반영
        // 승리 확정 확인 → 반영
        function confirmAndApply(winTeam) {
            const n1 = currentTeams.team1.length;
            const n2 = currentTeams.team2.length;
            if (n1 === 0 || n2 === 0 || n1 !== n2) {
                alert('먼저 짝수 인원으로 팀을 만들어주세요.');
                return;
            }
            const names1 = currentTeams.team1
                .map(id => roster.find(p => p.id === id)?.name)
                .filter(Boolean).join(', ');
            const names2 = currentTeams.team2
                .map(id => roster.find(p => p.id === id)?.name)
                .filter(Boolean).join(', ');

            const msg =
                `${winTeam === 1 ? '1팀 승리' : '2팀 승리'}로 점수를 반영할까요?`;

            if (confirm(msg)) applyResult(winTeam);
        }

        // 기존 applyResult는 그대로 두고, 이벤트 리스너만 교체
        document.getElementById('btnWin1').addEventListener('click', () => confirmAndApply(1));
        document.getElementById('btnWin2').addEventListener('click', () => confirmAndApply(2));

        function applyResult(winTeam) {
            const ids1 = new Set(currentTeams.team1), ids2 = new Set(currentTeams.team2);
            if (ids1.size === 0 || ids2.size === 0 || ids1.size !== ids2.size) { alert('먼저 짝수 인원으로 팀을 만들어주세요.'); return; }
            const team1 = roster.filter(p => ids1.has(p.id)), team2 = roster.filter(p => ids2.has(p.id));
            const mode = (scoringModeSel && scoringModeSel.value) || 'fixed';
            if (mode === 'elo') {
                const R1 = avg(team1.map(p => p.score)), R2 = avg(team2.map(p => p.score));
                const E1 = 1 / (1 + Math.pow(10, (R2 - R1) / 400)), E2 = 1 - E1;
                const K = Math.round(Number(eloKInput && eloKInput.value ? eloKInput.value : 32)) || 32;
                const S1 = (winTeam === 1 ? 1 : 0), S2 = (winTeam === 2 ? 1 : 0);
                const d1 = K * (S1 - E1), d2 = K * (S2 - E2);
                team1.forEach(p => {
                    const mult = isPlacement(p.games) ? 2 : 1; p.score = Math.round(clamp(p.score + d1 * mult, -9999, 9999));
                    p.games = (p.games || 0) + 1; if (winTeam === 1) p.wins = (p.wins || 0) + 1; else p.losses = (p.losses || 0) + 1;
                });
                team2.forEach(p => {
                    const mult = isPlacement(p.games) ? 2 : 1; p.score = Math.round(clamp(p.score + d2 * mult, -9999, 9999));
                    p.games = (p.games || 0) + 1; if (winTeam === 2) p.wins = (p.wins || 0) + 1; else p.losses = (p.losses || 0) + 1;
                });
            } else {
                const delta = Math.round(Number(winBonusInput && winBonusInput.value ? winBonusInput.value : 10)) || 10;
                roster.forEach(p => {
                    const in1 = ids1.has(p.id), in2 = ids2.has(p.id); if (!in1 && !in2) return;
                    const mult = isPlacement(p.games) ? 2 : 1;
                    if (in1) p.score += (winTeam === 1 ? delta * mult : -delta * mult);
                    if (in2) p.score += (winTeam === 2 ? delta * mult : -delta * mult);
                    p.score = Math.round(clamp(p.score, -9999, 9999)); p.games = (p.games || 0) + 1;
                    if (in1) { if (winTeam === 1) p.wins = (p.wins || 0) + 1; else p.losses = (p.losses || 0) + 1; }
                    if (in2) { if (winTeam === 2) p.wins = (p.wins || 0) + 1; else p.losses = (p.losses || 0) + 1; }
                });
            }
            saveLocal(); renderRoster(); renderTeams();
        }

        // 초기화
        function initPrefs() {
            try { const savedBonus = localStorage.getItem(WIN_BONUS_KEY); if (savedBonus && winBonusInput) winBonusInput.value = String(Math.round(Number(savedBonus) || 10)); } catch (_) { }
            if (winBonusInput) { winBonusInput.addEventListener('change', () => { const v = Math.round(Number(winBonusInput.value) || 10); winBonusInput.value = String(v); try { localStorage.setItem(WIN_BONUS_KEY, String(v)); } catch (_) { } }); }
            try {
                const savedMode = localStorage.getItem(MODE_KEY); if (savedMode && scoringModeSel) scoringModeSel.value = savedMode;
                const savedK = localStorage.getItem(ELO_K_KEY); if (savedK && eloKInput) eloKInput.value = String(Math.round(Number(savedK) || 32));
            } catch (_) { }
            if (scoringModeSel) { scoringModeSel.addEventListener('change', () => { try { localStorage.setItem(MODE_KEY, scoringModeSel.value); } catch (_) { } }); }
            if (eloKInput) { eloKInput.addEventListener('change', () => { const v = Math.round(Number(eloKInput.value) || 32); eloKInput.value = String(v); try { localStorage.setItem(ELO_K_KEY, String(v)); } catch (_) { } }); }
        }

        loadLocal(); initPrefs();
        roster = roster.map(p => ({ ...p, mainLine: normLine(p.mainLine || 'A'), subLine: normLine(p.subLine || 'A') }));
        saveLocal();
        renderRoster(); renderTeams();
    </script>
</body>

</html>





